#include <iostream>
#include <cstdio>
#include <algorithm>
#include <utility>

using namespace std;

/**
 * Proste odwzorowanie: numer Å›ciany -> kolor.
 * BTW: wolÄ™ British English wiÄ™c colOUr a nie colOr ;)
 * @param i Numer koloru.
 * @return Kod ASCII zmiany ustawieÅ„ konsoli.
 * @see http://ascii-table.com/ansi-escape-sequences.php
 */
int getColour(int i) {
	switch(i) {
		case 0: return 41;
		case 1: return 44;
		case 2: return 47;
		case 3: return 42;
		case 4: return 43;
		case 5: return 45;
		default: return 0;
	}
}

/**
 * Ustawia kolor c na wyjÅ›ciu out
 * @param out WyjÅ›cie.
 * @param c Kolor.
 * @see http://ascii-table.com/ansi-escape-sequences.php
 */
void setColour(ostream &out, int c=0) {
	out << "[" << c << "m";
}

/**
 * Template klasy opisujÄ…cej kostkÄ™ DxDxD.
 *
 * W tej klasie trzymam siÄ™ poniÅ¼szej notacji
 *   - i -- numer Å›ciany
 *   - j -- wiersz
 *   - k -- kolumna
 */
template <int D>
struct matrixCube {
	/**
	 * Macierz opisujÄ…ca ustawienie kostki.
	 *
	 * Numeracja: numer Å›ciany, wiersz, kolumna.
	 *
	 * Numer Å›ciany:
	 *   - czerwona = 0
	 *   - niebieska = 1
	 *   - biaÅ‚a = 2
	 *   - zielona = 3
	 *   - Å¼Ã³Å‚ta = 4
	 *   - pomaraÅ„czowa = 5
	 *
	 * Wiersz i kolumna zgodny z reprezentacjÄ… kostki w 2D.
	 *
	 * @see operator<<(ostream&, matrixCube&);
	 */
	int matrix[6][D][D];

	/**
	 * Funkcja identycznoÅ›ciowa (obrÃ³t wspÃ³Å‚rzÄ™dnych o zero stopni).
	 */
	pair<int,int> id(int x, int y) {
		return pair<int,int>(x,y);
	}
	
	/**
	 * ObrÃ³t wspÃ³Å‚rzÄ™dnych zgodnie ze wskazÃ³wkami zegara
	 */
	pair<int,int> cw(int x, int y) { 
		return pair<int,int>(y,D-1-x);
	}
	
	/**
	 * ObrÃ³t wspÃ³Å‚rzÄ™dnych przeciwnie do ruchu wskazÃ³wek zegara
	 */
	pair<int,int> ccw(int x, int y) {
		return pair<int,int>(D-1-y,x);
	}

	/**
	 * ObrÃ³t wspÃ³Å‚rzÄ™dnych o 180 stopni
	 */
	pair<int,int> ud(int x, int y) { 
		return pair<int,int>(D-1-x,D-1-y);
	}

	/**
	 * DomyÅ›lny konstruktor.
	 *
	 * Ustawia (uÅ‚oÅ¼onÄ…) kostkÄ™ w poÅ‚oÅ¼eniu domyÅ›lnym, tj. biaÅ‚ym do przodu, czerwonym do gÃ³ry
	 */
	matrixCube() {
		int i,j,k;
		for(i=0; i<6; ++i)
			for(j=0;j<D;++j)
				for(k=0;k<D;++k)
					matrix[i][j][k] = i;
	}

	/**
	 * Modyfikacja ukÅ‚adu kostki.
	 *
	 * Obraca danÄ… Å›cianÄ™ rFace przeciwnie do ruchu wskazÃ³wek zegara
	 * rTimes razy, obracajÄ…c jej rDepth poziomÃ³w.
	 *
	 * @param rFace Numer Å›ciany, wokÃ³Å‚ ktÃ³rej obracamy.
	 * @param rDepth IloÅ›Ä‡ poziomÃ³w, ktÃ³re obracamy.
	 * @param rTimes IloÅ›Ä‡ obrotÃ³w. Obroty zgodnie ze wskazÃ³wkami zegara. By obrÃ³ciÄ‡ w prawo podajemy rTimes=-1.
	 */
	matrixCube& rotate(int rFace, int rDepth, int rTimes);

	/**
	 * DostÄ™p do wewnÄ™trznej macierzy.
	 */
	inline int& operator()(int i, int j, int k) {
		return matrix[i][j][k];
	}

	template <int R>
	friend ostream& operator<<(ostream&, matrixCube<R>&);
};

int main() {
	matrixCube<4> test00;
	matrixCube<4> test01;
	matrixCube<4> test02;
	matrixCube<4> test03;
	matrixCube<4> test04;
	matrixCube<4> test05;
	matrixCube<4> test105;
	matrixCube<4> test1;
	matrixCube<3> testA;
	cout << "test00:\n" << test00.rotate(0, 1, 1);
	cout << "test01:\n" << test01.rotate(1, 1, 1);
	cout << "test02:\n" << test02.rotate(2, 1, 1);
	cout << "test03:\n" << test03.rotate(3, 1, 1);
	cout << "test04:\n" << test04.rotate(4, 1, 1);
	cout << "test05:\n" << test05.rotate(5, 1, 1);
	cout << "test05:\n" << test05.rotate(5, 1, 1);
	cout << "test105:\n";
	cout << test105.rotate(1, 1, 1);
	cout << test105.rotate(0,2,1);
	cout << test105.rotate(5,1,1);
	cout << "test1:\n" << test1.rotate(1,4,1);
	cout << "testA:\n" << testA;
	testA(0,0,0) = 0;
	cout << testA << testA.rotate(2,1,1);
	return 0;
}

/**
 * WyÅ›wietlanie kostki na ekranie.
 *
 * Funkcja specyficzna dla powÅ‚oki Linuksa.
 * @param out Potok wyjÅ›ciowy.
 * @param m Kostka do wyÅ›wietlenia.
 * @see geColour
 * @see setColour
 */
template <int D>
ostream& operator<<(ostream &out, matrixCube<D> &m) {
	static string dashes = string(D, '-') + "+";
	static string spaces = string(D, ' ');
	int i,j,k;

	setColour(out); // default
	out << spaces << " +" << dashes << "\n";
	for(j=0; j<D; ++j) {
		out << spaces << " |";
		for(k=0; k<D; ++k) {
			setColour(out, getColour(m.matrix[0][j][k]));
			out << m.matrix[0][j][k];
		}
		out << "[0m"; // default
		out << "|\n";
	}
	out << "+" << dashes << dashes << dashes << dashes << "\n";
	for(j=0; j<D;++j) {
		for(i=1; i<5; ++i) {
			out << "|";
			for(k=0; k<D; ++k) {
				setColour(out, getColour(m.matrix[i][j][k]));
				out << m.matrix[i][j][k];
			}
			setColour(out); // default
		}
		out << "|\n";
	}
	setColour(out); // default
	out << "+" << dashes << dashes << dashes << dashes << "\n";
	for(j=0; j<D; ++j) {
		out << spaces << " |";
		for(k=0; k<D; ++k) {
			setColour(out, getColour(m.matrix[5][j][k]));
			out << m.matrix[5][j][k];
		}
		setColour(out); // default
		out << "|\n";
	}
	out << spaces << " +" << dashes << "\n";
	return out;
}


template <int D>
matrixCube<D>& matrixCube<D>::rotate(int rFace, int rDepth, int rTimes) {

	/*
	 * Tablica obrotÃ³w.
	 * Zawiera informacje o przejÅ›ciu krawÄ™dzi na krawÄ™dÅº przy danym obrocie.
	 *
	 * PrzykÅ‚adowo:
	 * ObrÃ³t wzglÄ™dem Å›ciany 2 oznacza, Å¼e czÄ™Å›Ä‡ Å›ciany 0 przechodzi w 1, czÄ™Å›Ä‡ 1
	 * w 5, czÄ™Å›Ä‡ 5 w 3, oraz czÄ™Å›Ä‡ 3 w 0.
	 */
	int rots[][4] = {
		{4,1,2,3},
		{0,4,5,2},
		{0,1,5,3},
		{0,2,5,4},
		{0,3,5,1},
		{2,1,4,3}
	};

	/*
	 * Ten potworek tutaj to dwuwymiarowa tablica wskaÅºnikÃ³w na funkcje
	 * skÅ‚adowe matrixCube przyjmujÄ…ce dwa inty i zwracajÄ…ce pare intÃ³w.
	 */
	pair<int,int> (matrixCube::*convCoords[][4])(int,int) = { 
		{ &matrixCube::id,  &matrixCube::id,  &matrixCube::id,  &matrixCube::id  },
		{ &matrixCube::ccw, &matrixCube::cw,  &matrixCube::ccw, &matrixCube::ccw },
		{ &matrixCube::ud,  &matrixCube::cw,  &matrixCube::id,  &matrixCube::ccw },
		{ &matrixCube::cw,  &matrixCube::cw,  &matrixCube::cw,  &matrixCube::ccw },
		{ &matrixCube::id,  &matrixCube::cw,  &matrixCube::ud,  &matrixCube::ccw },
		{ &matrixCube::ud,  &matrixCube::ud,  &matrixCube::ud,  &matrixCube::ud  },
	};

	int nMatrix[6][D][D];
	int *nMatrixH = &nMatrix[0][0][0];
	int *matrixH = &matrix[0][0][0];
	int i,j,k;
	int cnt,i2;

	rTimes %= 4;
	if(!rTimes)
		return *this;

	copy((int*)matrix, (int*)matrix+6*D*D, (int*)nMatrix);

	// obrÃ³t przedniej Å›ciany
	for(cnt = 0; cnt<rTimes; ++cnt)
		for(j=0; j<D; ++j)
			for(k=0; k<D; ++k)
				nMatrix[rFace][D-1-k][j] = matrix[rFace][j][k];

	// obrÃ³t pozostaÅ‚ych Å›cian
	while(rTimes-- > 0) {
		for(cnt = 0; cnt<4; ++cnt) {
			i = rots[rFace][cnt];
			i2 = rots[rFace][(cnt+1)%4];
			pair<int,int> (matrixCube::*conv)(int,int) = convCoords[rFace][cnt];
			pair<int,int> (matrixCube::*conv2)(int,int) = convCoords[rFace][(cnt+1)%4];
			for(j=0; j<rDepth; ++j) {
				for(k=0; k<D; ++k) {
					pair<int,int> c = (this->*conv)(j,k);
					int &jj = c.first;
					int &kk = c.second;
					pair<int,int> c2 = (this->*conv2)(j,k);
					int &jj2 = c2.first;
					int &kk2 = c2.second;
					nMatrix[i2][jj2][kk2] = matrix[i][jj][kk];
				}
			}
		}

		copy((int*)nMatrix, (int*)nMatrix+6*D*D, (int*)matrix);
	}

	return *this;
}

